#!/usr/bin/env node
// jshint ignore: start

/** @file Generates data (usually .json) files in same directory for use by karma unit tests */

const fs = require('fs');
const path = require('path');
const baseDir = __dirname;

(() => {

    const randomNumbers = generateRandomNumbers(100).sort((a, b) => a -b);
    savePrettyJSON({data: randomNumbers}, `${baseDir}/_randomNumbers.json`,{ meta: true });

    const randomNumbersRounded = createRoundedNumbersData(randomNumbers);
    savePrettyJSON({data: randomNumbersRounded}, `${baseDir}/_randomNumbersRounded.json`, { meta: true });

    const dividedNumbers = createDividedNumbersData(100);
    savePrettyJSON({data: dividedNumbers}, `${baseDir}/_dividedNumbers.json`, { meta: true });

    const dividedNumbersRounded = createDividedNumbersAllRoundedData(20);
    savePrettyJSON({data: dividedNumbersRounded}, `${baseDir}/_dividedNumbersRounded.json`, { meta: true });

})();

/**
 * @param {number} numbersToGenerate - How many numbers to generate
 * @param {number} [multiplyFactor=1000000] - Factor by which to multiply random number
 * @returns {Array.<number>} - Array of generated numbers
 */
function generateRandomNumbers(numbersToGenerate, multiplyFactor = 1000000) {
    let randomNumberCount = 0;
    let number;
    let numbers = [];
    while (randomNumberCount++ < numbersToGenerate) {
        number = Math.random() * multiplyFactor / randomNumberCount; 
        if (parseInt(number)) {
            numbers.push(number);
        }
    }
    return numbers;
}


/**
 * @param {number} - How many numbers to generate
 * @returns {Array.Array.<number>} - Returns array containing [dividend, divisor, quotient]
 */
function createDividedNumbersData(numbersCount) {
    let result = [];
    while (numbersCount--) {
        let dividend = Math.random() * 100000;
        let divisor = Math.random() * 100000;
        let quotient = dividend / divisor;
        result.push([dividend, divisor, quotient]);
    }
    return result;
}

/**
 * @param {number} numbersCount - How many numbers to generate
 * @param {number} decimalPlacesCount - How many variations to generate base on decimal places
 * @returns {Array.Array.<number>} - Returns array containing [dividend, divisor, quotient]
 */
function createDividedNumbersAllRoundedData(numbersCount, decimalPlacesCount = 14) {
    let result = [];
    let dividend;
    let divisor;
    let quotient;

    while (numbersCount--) {
        dividend = Math.random() * 100000;
        divisor = Math.random() * 100000;
        quotient = dividend / divisor;
        
        result.push([dividend, divisor, quotient]);

        let iterationCount = decimalPlacesCount + 1;
        let dividendIteration;
        let divisorIteration;
        let quotientIteration;

        while (iterationCount--) {
            // dividendIteration = parseFloat(dividend.toFixed(iterationCount));
            // divisorIteration = parseFloat(divisor.toFixed(iterationCount));
            dividendIteration = roundNumber(dividend,iterationCount);
            divisorIteration = roundNumber(divisor,iterationCount);
            if (parseInt(dividendIteration) && parseInt(divisorIteration)) {
                quotientIteration = dividendIteration / divisorIteration;
                result.push([ dividendIteration, divisorIteration, quotientIteration ]);
            }
        }
    }
    return result;
}


/**
 * @param  {Array.<number>} - Numbers to round all decimal place variations of
 * @returns {Array.Array.<number>} - Each number in original array has been replaced with an array containing
 */
function createRoundedNumbersData(numbers) {
    return numbers.map(number => [number, ... getAllRoundedForNumber(number)]);
}

/**
 * @param  {number} number - The number to round
 * @param  {number} [decimalPlacesCount=14] - How many versions of number to round to each decimal place count
 * @returns {Array.Array.<number>} - Nested arrays include the original number, followed by all iterations
 * @example getAllRoundedForNumber(1.12345, 3); // Returns [1.123, 1.12, 1.1, 1]
 */
function getAllRoundedForNumber(number, decimalPlacesCount = 14) {
    let numbers = [];
    var result;
    decimalPlacesCount += 1;
    while (decimalPlacesCount--) {
        result = roundNumber(number, decimalPlacesCount);
        if (parseInt(result)) {
            numbers.push(result);
        }
    }
    return numbers;
}


/**
 * @param  {object} object - Object to prettify and save to filesystem
 * @param  {string} filename - Output filename, including path.
 * @param  {object} [options]
 * @param  {*} [options.meta='<gen info>'] - Any metadata for output json file
 * @returns {string} - Returns multiline string of 'prettified' JSON.
 */
function savePrettyJSON(object, filename, options = {}) {
    let output = {};
    let prettyOutput = '';

    if (options.meta) {
        output.meta = options.meta === true ? `'${stripParentPaths(filename)}' was generated by '${stripParentPaths(__filename)}' on '${Date()}'` : options.meta;
    }

    Object.assign(output, object);

    prettyOutput = JSON.stringify(output, null, '\t');

    fs.writeFile(filename, prettyOutput, 'utf8',() => {
        console.log(`\x1b[36m[generate-test-data]\x1b[0m Generated \x1b[37m${stripParentPaths(filename)}`);
    });

    return prettyOutput;
}


/**
 * @param  {number} number - number to round
 * @param  {number} decimalPlacesCount - number of decimal places to round to
 * @returns {number}
 */
function roundNumber(number, decimalPlacesCount) {
    return Number(Math.round(number+'e'+decimalPlacesCount)+'e-'+decimalPlacesCount);
}

/**
 * @param  {string} path
 * @returns {string}
 */
function stripParentPaths(path) {
  let cleanPath = path.split('/mall-app/')[1];
    return cleanPath ? `/${cleanPath}` : path;
}
