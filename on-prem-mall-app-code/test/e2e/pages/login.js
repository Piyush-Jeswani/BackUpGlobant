// START set API URL for direct login, creating users, etc.
// use config.js in the main app (src/components/common/config.js)
let apiBaseUrl = 'https://rdc-api-staging.shoppertrak.com/api/v1'; // default
const loadUtils = require('./common-utils/load-utils.js');

const mockAngularModule = {
  constant(key, value) {
    if (key === 'apiUrl') {
      apiBaseUrl = value;
    }
    return this;
  }
};
const mockContextWithAngular = {
  angular: {
    module() {
      return mockAngularModule;
    }
  }
};
loadUtils.resolveFileWithNewContext(`${__dirname}/../../../src/components/common/config.js`, mockContextWithAngular);
// END set API URL
// console logs very helpful when debugging and reading build logs
console.log('browser.baseUrl:', browser.baseUrl);
console.log('apiBaseUrl:', apiBaseUrl);

let users = require('../data/users.js');
let request = require('request');
let randomString = require('randomstring');

let tokens = {};
let credentials = {
  'e2e-tester': 'Feast-Bribery-2',
  'e2e-org-tester': 'Able-Crack-5',
  'e2e-mi-tester': 'Scientific-Honor-2',
  'e2e-test-lang-es-mx': 'Steer-Dry-Bath-8',
  'e2e-test-lang-es-mx-custom': 'Prompt-Fill-Hide-4',
  'e2e-northface-org-admin':'shoppertrak',
  'org-user-tester' : 'shoppertrak'
};

module.exports = {

  fields: {
    username: element(by.name('username')),
    password: element(by.name('password')),
    loginButton: element(by.name('submitButton')),
    error: element(by.binding('vm.loginError'))
  },

  go() {
    browser.get('#/');
  },

  loginAsSuperUser() {
    this.fields.username.clear();
    this.fields.password.clear();
    this.fields.username.sendKeys(users.superUser.userName);
    this.fields.password.sendKeys(users.superUser.password);
    this.fields.loginButton.click();
  },

  loginAsMondayUser() {
    this.fields.username.clear();
    this.fields.password.clear();
    this.fields.username.sendKeys(users.mondayUser.userName);
    this.fields.password.sendKeys(users.mondayUser.password);
    this.fields.loginButton.click();
  },

  loginAsTestLangUser(locale, customDate) {
    let user = this.getTestLangUser(locale, customDate);
    this.fields.username.clear();
    this.fields.password.clear();
    this.fields.username.sendKeys(user.userName);
    this.fields.password.sendKeys(user.password);
    this.fields.loginButton.click();
  },

  loginAsUser(user) { // for cache priming users
    this.fields.username.clear();
    this.fields.password.clear();
    this.fields.username.sendKeys(user.userName);
    this.fields.password.sendKeys(user.password);
    this.fields.loginButton.click();
  },

  getUserWithToken(callback, userData) {
    runInControlFlow(this.getUserPromise, this, userData, callback);
  },

  getUserPromise(_userData) {
    const userData = _userData || users.superUser;

    const deferred = protractor.promise.defer();

    // with no params, getTokenPromise gets the token of a superuser
    // we need a superuser token (an adminUsersToken) to create test users
    this.getTokenPromise().then(adminUsersToken => {
      // past first wait / async (after getting superUser token)
      const randomSuffix = `-${randomString.generate({
        length: 8,
        readable: true
      })}`;
      const username = userData.userName + randomSuffix;
      const password = credentials[userData.userName] + randomSuffix;

      const createUserPostBody = {
        username,
        password,
        superuser: userData.superuser,
        email: 'noreply@shoppertrak.com',
        fullname: 'Test User',
        title: 'Generated by e2e tests',
        thousands_separator: userData.numberFormat.thousandsSeparator,
        decimal_separator: userData.numberFormat.decimalSeparator,
        date_format_mask: userData.dateFormat,
        locale: userData.locale,
        temperature_format: userData.weatherOptions.tempUnits,
        velocity_format: userData.weatherOptions.windSpeedUnits,
        preferences: {
          calendar_id: 65
        }
      };

      request.post({
        json: true,
        baseUrl: apiBaseUrl,
        url: '/users',
        body: createUserPostBody,
        headers: {
          Authorization: `Bearer ${adminUsersToken}`
        }
      },
        (error, response) => {
          // past 2nd wait / async (to generate test user)
          if (response.statusCode !== 200) {
            deferred.reject(`Could not create temporary e2e user, got status code = ${response.statusCode}`);
          }
          this.getTokenPromise(username, password).then(newUserToken => {
            // past 3rd wait / async (to get token for generated test user)
            deferred.fulfill({ token: newUserToken, userId: response.body.result[0]._id, username, adminUsersToken, createUserPostBody });
          });
        });
    });

    return deferred.promise;
  },

  getOrgUserWithToken(callback, userData, hasOrgIndex) {
    runInControlFlow(this.getOrgUserPromise, this, userData, callback, hasOrgIndex);
  },

  getOrgUserPromise(_userData, hasOrgIndex) { // used to create custom non-superusers (complete access to 1 org) for e2e tests
    const userData = _userData || users.testMiUser;
    const deferred = protractor.promise.defer();
    this.getUserPromise(userData) // add new non-superuser to defaultOrg, using adminUser's account
      .then(userIdAndToken => { // non-superuser has been created in STAn pool, must be added to defaultOrg
        const createOrgUserPostBody = userIdAndToken.createUserPostBody;
        createOrgUserPostBody.miAccess = true;
        createOrgUserPostBody.miIndexFlag = hasOrgIndex;
        createOrgUserPostBody.accessMap = {
          setup: {
            tags: [],
            organizations: [userData.defaultOrgId],
            sites: [],
            locations: [],
            orgs_admin: [],
            mi_orgs: [],
            belongs_to: []
          },
          actual: {
            organizations: [],
            sites: [],
            locations: []
          },
          partial: {
            organizations: [],
            sites: []
          }
        };
        request.post({ // POST to add new non-superuser to defaultOrg, using adminUser's account
          json: true,
          baseUrl: apiBaseUrl,
          url: `/organizations/${userData.defaultOrgId}/users`,
          body: createOrgUserPostBody,
          headers: {
            Authorization: `Bearer ${userIdAndToken.adminUsersToken}`
          }
        },
          (error, response) => {
            // past 2nd wait / async (to generate test user)
            if (response.statusCode !== 200) {
              deferred.reject(`Could not add new test user to org ${userData.defaultOrgId}, got status code = ${response.statusCode}`);
            }
            this.getTokenPromise(createOrgUserPostBody.username, createOrgUserPostBody.password, true).then(newUserToken => {
              // past 3rd wait / async (to get token for generated test user)
              deferred.fulfill({ token: newUserToken, userId: response.body.result[0]._id, username: createOrgUserPostBody.username });
            });
          });
      });
    return deferred.promise;
  },

  deleteUser(callback, userId) {
    runInControlFlow(this.deleteUserPromise, this, userId, callback);
  },


  deleteUserPromise(userId) {
    let deferred = protractor.promise.defer();

    // with no params, getTokenPromise gets the token of a superuser
    // we need a superuser token to create test users
    this.getTokenPromise().then(superUserToken => {
      // past first wait / async (after getting superUser token)

      request.delete({
        json: true,
        baseUrl: apiBaseUrl,
        url: `/users/${userId}`,
        headers: {
          Authorization: `Bearer ${superUserToken}`
        }
      },
        (error, response) => {
          // past 2nd wait / async (to generate test user)
          if (response.statusCode !== 200) {
            deferred.reject(`Could not delete temporary e2e user ${userId}, got status code = ${response.statusCode}`);
          }
          deferred.fulfill(userId);
        });
    });

    return deferred.promise;
  },

  getToken(callback, username) {
    runInControlFlow(this.getTokenPromise, this, username, callback);
  },

  getTokenPromise(_username, _password, noCache) { // noCache gets user's latest token in case their access has changed (used when adding non-superusers to orgs)
    let username = _username || users.superUser.userName;
    let password = _password || credentials[username];

    let deferred = protractor.promise.defer();

    if (tokens[username] && noCache !== true) {
      deferred.fulfill(tokens[username]);
    } else {
      request.post({
        json: true,
        baseUrl: apiBaseUrl,
        url: '/auth',
        body: {
          username,
          password
        }
      },
        (error, response) => {
          let token = response.body.result[0].token;
          tokens[username] = token;
          deferred.fulfill(token);
        });
    }

    return deferred.promise;
  },

  getTestLangUserToken(callback, locale, customDate) {
    let user = this.getTestLangUser(locale, customDate);
    let username = user.userName;

    return this.getToken(callback, username);
  },

  getTestLangUser(locale, customDate) {
    let customPdKey = 'defaultPd';
    if (customDate) {
      customPdKey = 'customPd';
    }
    return users.testLanguageUsers[locale][customPdKey];
  }
};

function runInControlFlow(func, scope, argument, callback, argument2) {
  // any callbacks/promises must be part of Webdriver's control flow.
  // promises from selectors in the page objects are already part of the control flow.
  // https://spin.atomicobject.com/2014/12/17/asynchronous-testing-protractor-angular/
  let flow = browser.controlFlow();

  let tokenPromise = flow.execute(func.bind(scope, argument, argument2));

  tokenPromise.then(callback, rejectionError => {
    throw new Error(`failed to run, got error: ${rejectionError}`);
  });
}
